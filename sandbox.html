<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>sandbox</title>
  <style>
  div.container {
    display: flex;   /* Magic begins */
    flex-direction: row;
    width: 100vw;
    height: 50vw;
  }
  div.sim {
    flex-grow: 1;
    width: 50%;
  }
  div
  .link {
    stroke: #bbb;
  }
  .node circle {
    stroke-width: 2px;
    r: 2px
  }
  *
  {
    margin:0;
    padding:0;
  }
  div.text
  {
    flex-grow: 1;
    width: 50%;
    padding-left: 5%;
    padding-right: 1%;
    align-self: flex-end;
    text-align: right;
    font-family: Futura, "Trebuchet MS", Arial, sans-serif;
    font-weight: bold;
    color: black;
  }
  h1
  {
    margin: 3%;
    font-size: 32px;
  }
  h2
  {
    margin: 3%;
    font-size: 14px;
  }
  p
  {
    margin: 3%;
    font-size: 16px;
  }

  </style>
  <script src="https://d3js.org/d3.v5.js"></script>
</head>
<body>
  <div  class="container">
    <div class="sim" id="sim"> </div>
    <div class="text">
      <h1> The sandbox </h1>
      <p> somewhere for me to play with new ideas </p>
    </div>
  </div>
  <script type="text/javascript">
    var width=0.5*window.innerWidth || document.body.clientWidth;
    var height=width;
    var svg=d3.select("#sim").append("svg");
    svg.attr('width',width)
      .attr('height',height);

    var G=6.67e-11; // in SI
    var mSun=2e30;
    var kpc=3e19;
    var Gyr=3.15e16;
    var Galt=G*(mSun*(Gyr**2))/(kpc**3);

    var rHat=[0,0,0]
    var a1=[0,0,0]
    var a2=[0,0,0]

    function gravParticle(){
      this.id=0
      this.m=1e6
      this.x=[0,0,0]
      this.v=[0,0,0]
      this.a=[0,0,0]
      this.flag=0
      this.c='black'
      this.r=2
      this.smooth=0.1
    }
    function gravity(p1,p2){ // calculating and updating the acceleration of a pair of particles
      var r=Math.sqrt((p2.x[0]-p1.x[0])**2 + (p2.x[1]-p1.x[1])**2 + (p2.x[2]-p1.x[2])**2 + p1.smooth**2 + p2.smooth**2);

      rHat[0]=(p2.x[0]-p1.x[0])/r;
      rHat[1]=(p2.x[1]-p1.x[1])/r;
      rHat[2]=(p2.x[2]-p1.x[2])/r;

      a1[0]=rHat[0]*Galt*p2.m/(r**2);
      a1[1]=rHat[1]*Galt*p2.m/(r**2);
      a1[2]=rHat[2]*Galt*p2.m/(r**2);

      a2[0]=-rHat[0]*Galt*p1.m/(r**2);
      a2[1]=-rHat[1]*Galt*p1.m/(r**2);
      a2[2]=-rHat[2]*Galt*p1.m/(r**2);

      p1.a[0]=p1.a[0]+a1[0]
      p1.a[1]=p1.a[1]+a1[1]
      p1.a[2]=p1.a[2]+a1[2]

      p2.a[0]=p2.a[0]+a2[0]
      p2.a[1]=p2.a[1]+a2[1]
      p2.a[2]=p2.a[2]+a2[2]
    }
    function update(ps){
      clearAcc(ps)
      for (var i=0; i<nParticles; i++){
        if (ps[i].flag == 1){
          var index=ps[i].id;
          for (var j=i+1; j<nParticles; j++){
            gravity(ps[i],ps[j]);
          }
        }
      }
    }
    var boxSize=30;
    var ps=[];
    var host = new gravParticle();
    host.m=1e11;
    host.flag=1;
    host.c='red'
    host.r=20
    host.smooth=1
    var sat = new gravParticle();
    sat.m=1e10;
    sat.id=1;
    sat.flag=1;
    sat.x=[20,0,0];
    sat.v=[0,-200,0];
    sat.r=10
    sat.c='blue'
    sat.smooth=0.5
    host.v[1]=-(sat.m/host.m)*sat.v[1]
    ps.push(host);
    ps.push(sat);
    rMin=1
    rMax=20
    for (var i=0;i<5000;i++){
      var pNew = new gravParticle();
      pNew.m=1e8;
      pNew.id=i+2;
      pNew.flag=0;
      var theta=Math.PI*Math.random();
      var phi=2*Math.PI*Math.random();
      var r=Math.sqrt(rMin**2+Math.random()*(rMax**2 - rMin**2));
      pNew.x=[r*Math.cos(phi)*Math.sin(theta),r*Math.sin(phi)*Math.sin(theta),r*Math.cos(theta)];
      pNew.v=[150*(-1+2*Math.random()),150*(-1+2*Math.random()),150*(-1+2*Math.random())];
      pNew.smooth=0.1
      ps.push(pNew);
    }

    var nParticles=ps.length;

    var circles=svg.selectAll(".node")
      .data(ps)
      .enter()
      .append('circle')
      .attr('id',function(d) { return "particle" + d.id; })
      .attr('r',function(d) { return d.r; })
      .style("fill", function(d) {return d.c})
      .attr('cx', function(d) {return width*(d.x[0]+boxSize)/(2*boxSize);})
      .attr('cy', function(d) {return width*(d.x[1]+boxSize)/(2*boxSize);});

    var dt=0.001

    update(ps);

    function evolve() {
      for (var i=0; i< nParticles; i++){
        ps[i].v[0]=ps[i].v[0]+ps[i].a[0]*dt/2;
        ps[i].v[1]=ps[i].v[1]+ps[i].a[1]*dt/2;
        ps[i].v[2]=ps[i].v[2]+ps[i].a[2]*dt/2;

        ps[i].x[0]=ps[i].x[0]+ps[i].v[0]*dt;
        ps[i].x[1]=ps[i].x[1]+ps[i].v[1]*dt;
        ps[i].x[2]=ps[i].x[2]+ps[i].v[2]*dt;
      }
      update(ps); // finds new acceleration
      for (var i=0; i < nParticles; i++){
        ps[i].v[0]=ps[i].v[0]+ps[i].a[0]*dt/2;
        ps[i].v[1]=ps[i].v[1]+ps[i].a[1]*dt/2;
        ps[i].v[2]=ps[i].v[2]+ps[i].a[2]*dt/2;

        var thisCircle=d3.select('#particle'+ps[i].id);
        thisCircle
          .attr('cx', function(d) {return width*(d.x[0]+boxSize)/(2*boxSize);})
          .attr('cy',function(d) {return width*(d.x[1]+boxSize)/(2*boxSize);})
          .style("fill", function(d) {
            if (d.flag==0){ return d3.interpolateSpectral((d.x[2]+boxSize)/(2*boxSize))}
            return d.c
          })
      }
    }

    function clearAcc(ps){ // clearing old accelerations at each step
      for (var i = 0; i < ps.length; i++) {
        ps[i].a=[0,0,0];
      }
    }

    var startStop=1
    document.body.onkeyup = function(e){
      if(e.keyCode == 32){
          startStop=(startStop+1)%2
          if (startStop==0) {timer.stop();}
          if (startStop==1) {timer.restart(evolve,20);}
      }
    }
    var timer=d3.interval(evolve,50);
  </script>
</body>
</html>
